package com.axamit.aop.osgi.weaver;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.security.ProtectionDomain;

/**
 * Allows to define dynamically a new class in a target bundle.
 *
 * Used to add $AjcClosure classes generated by @Around advices into target bundle classloader.
 * Otherwise, main woven class will throw ClassNotFoundException for the closure class.
 * Important: we hardly can add new class until dynamic imports process after the woven class gets into DEFINED state.
 * In other case ClassNotFoundException will be thrown for org.aspectj.runtime.internal.Around class or other because
 * it is not yet available to the target bundle classloader. If a target bundle is under control, adding servicemix bundle fixes.
 * To avoid importing statically that aspectj bundle we rather store $AjcClosure{N} bytecode in a separate, temporary
 * collection and wait using WovenClassListener until the woven class is DEFINED
 * (and therefore dynamic imports are added to the bundle requirements).
 */
public class ClassLoaderHelper {

    private static final Logger LOGGER = LoggerFactory.getLogger(ClassLoaderHelper.class);

    private static final String DEFINE_CLASS_METHOD = "defineClass";

    private Method defineClassMethod;

    private Method defineClassWithProtectionDomainMethod;

    public ClassLoaderHelper() {

        try {
            defineClassMethod = ClassLoader.class.getDeclaredMethod(DEFINE_CLASS_METHOD, String.class,
                    byte[].class, int.class, int.class );
            defineClassMethod.setAccessible(true);

            defineClassWithProtectionDomainMethod = ClassLoader.class.getDeclaredMethod(DEFINE_CLASS_METHOD,
                    String.class, byte[].class, int.class, int.class, ProtectionDomain.class);
            defineClassWithProtectionDomainMethod.setAccessible(true);

        } catch (NoSuchMethodException e) {
            LOGGER.error(e.getMessage(), e);
        }
    }

    // Have to redefine defineClass method from ClassLoaderWeavingAdaptor as they are private
    public void defineClass(ClassLoader loader, String name, byte[] bytes, ProtectionDomain protectionDomain) {
        if (LOGGER.isTraceEnabled()) {
            LOGGER.trace("defineClass", this, new Object[]{loader, name, bytes, protectionDomain});
        }

        LOGGER.debug("defining class {}", name);

        try {
            Object clazz = protectionDomain == null
                    ? this.defineClassMethod.invoke(loader, name, bytes, 0, bytes.length)
                    : this.defineClassWithProtectionDomainMethod.invoke(loader, name, bytes, 0, bytes.length, protectionDomain);

        } catch (IllegalAccessException | InvocationTargetException e) {
            LOGGER.error(e.getMessage(), e);
        } catch (Exception e) {
            LOGGER.warn("define generated class failed", e);
        }
    }

}
